}
#(var_xb, prop_case1, e_lamb, prev)
(sumx <- apply((x<-replicate(50, runme(4,.5,5,.01))), 1, mean))
# c(sumx[4]+ sumx[5], sumx[6])
(sumx <- apply((x<-replicate(50, runme(8,.5,5,.1))), 1, mean))
# c(sumx[4]+ sumx[5], sumx[6])
(sumx <- apply((x<-replicate(50, runme(8,.5,5,.07))), 1, mean))
# c(sumx[4]+ sumx[5], sumx[6])
(sumx <- apply((x<-replicate(50, runme(8,.5,3,.03))), 1, mean))
# c(sumx[4]+ sumx[5], sumx[6])
(sumx <- apply((x<-replicate(50, runme(8,.5,2.5,.02))), 1, mean))
# c(sumx[4]+ sumx[5], sumx[6])
(sumx <- apply((x<-replicate(50, runme(10,.5,2.7,.015))), 1, mean))
runme <- function (var_xb, prop_case1, e_lamb, prev)
{
ncase1 <- prop_case1 * n_total/2
ncont1 <- n_total/2 - ncase1
ncase2 <- n_total/2 - ncase1
ncont2 <- n_total/2 - ncont1
betas <- sqrt( (var_xb / 3) / c(.25, 168.75, 1)) # (sex, age, Z)
LG <- log(e_lamb) # increase in penetrance
interc <- qlogis(prev) - sum(betas * c(.5,42.5,0)) - LG * mean_W # logit(Preval) - b * E(X) - lambda * E(epistatis)
nc <- nu <- 0 # Track number of case/control for pop 1
# Sample from population 1 -- no ascertainment done
sample_data_pop1 <- get_sim_pop(n_total, maf_W1_pop1, maf_W2_pop1, ncase1, ncont1, interc, LG, betas)
while(any(is.na(sample_data_pop1$Y))){
sample_data_pop1 <- get_sim_pop(n_total, maf_W1_pop1, maf_W2_pop1, ncase1, ncont1, interc, LG, betas)
}
# Sample from population 2 -- no ascertainment done
sample_data_pop2 <- get_sim_pop(n_total, maf_W1_pop2, maf_W2_pop2, ncase2, ncont2, interc, LG, betas)
while(any(is.na(sample_data_pop2$Y))){
sample_data_pop2 <- get_sim_pop(n_total, maf_W1_pop2, maf_W2_pop2, ncase2, ncont2, interc, LG, betas)
}
sample_data <- rbind(sample_data_pop1, sample_data_pop2)
# rm(sample_data_pop1, sample_data_pop2)
with(sample_data, c(Penetrance = tapply(Y, (W1 > 0) & (W2 > 0), mean), muY = mean(Y), Sum_vars = var(pis)+mean(pis*(1-pis)),Tot_var = var(Y), Prop_cov_var = var(pis)/(var(pis)+ mean(pis*(1-pis))) ) )
}
(sumx <- apply((x<-replicate(50, runme(10,.5,2.7,.01))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(12,.5,2.9,.01))), 1, mean))
get_sim_pop <- function(n_total, maf_W1, maf_W2, ncase, ncont, int, LG, betas){
n_sim <- n_total * 10
mean_W <- (1 - (1-maf_W1)^2) * (1- (1 - maf_W2)^2)
int <- int - LG * mean_W  # Subtract LG * E(epistatis)
sim_data = data.frame(sex = rbinom(n_sim, 1, .5),
age = runif(n_sim, 20, 65),
Z = rnorm(n_sim),
W1 = rbinom(n_sim, 2, maf_W1),
W2 = rbinom(n_sim, 2, maf_W2))
sim_data$pis <- with(sim_data, plogis(int + LG * ((W1 > 0) & (W2 > 0)) + sex * betas[1] + age * betas[2] + Z * betas[3]))
sim_data$Y <- rbinom(n_sim, 1, prob = sim_data$pis)
# cases <- sim_data$Y == 1
# sim_data <- rbind(sim_data[cases,][1:ncase,], sim_data[!cases,][1:ncont,])
return(sim_data)
}
runme <- function (var_xb, prop_case1, e_lamb, prev)
{
ncase1 <- prop_case1 * n_total/2
ncont1 <- n_total/2 - ncase1
ncase2 <- n_total/2 - ncase1
ncont2 <- n_total/2 - ncont1
betas <- sqrt( (var_xb / 3) / c(.25, 168.75, 1)) # (sex, age, Z)
LG <- log(e_lamb) # increase in penetrance
interc <- qlogis(prev) - sum(betas * c(.5,42.5,0)) # logit(Preval) - b * E(X)
nc <- nu <- 0 # Track number of case/control for pop 1
# Sample from population 1 -- no ascertainment done
sample_data_pop1 <- get_sim_pop(n_total, maf_W1_pop1, maf_W2_pop1, ncase1, ncont1, interc, LG, betas)
while(any(is.na(sample_data_pop1$Y))){
sample_data_pop1 <- get_sim_pop(n_total, maf_W1_pop1, maf_W2_pop1, ncase1, ncont1, interc, LG, betas)
}
# Sample from population 2 -- no ascertainment done
sample_data_pop2 <- get_sim_pop(n_total, maf_W1_pop2, maf_W2_pop2, ncase2, ncont2, interc, LG, betas)
while(any(is.na(sample_data_pop2$Y))){
sample_data_pop2 <- get_sim_pop(n_total, maf_W1_pop2, maf_W2_pop2, ncase2, ncont2, interc, LG, betas)
}
sample_data <- rbind(sample_data_pop1, sample_data_pop2)
# rm(sample_data_pop1, sample_data_pop2)
with(sample_data, c(Penetrance = tapply(Y, (W1 > 0) & (W2 > 0), mean), muY = mean(Y), Sum_vars = var(pis)+mean(pis*(1-pis)),Tot_var = var(Y), Prop_cov_var = var(pis)/(var(pis)+ mean(pis*(1-pis))) ) )
}
#runme(var_xb, prop_case1, e_lamb, prev)
(sumx <- apply((x<-replicate(50, runme(12,.5,2.9,.01))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11,.5,3.2,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(12,.5,4,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.8,.5,4.3,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.8,.5,4.5,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.5,.5,4.7,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.5,.5,4.7,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.5,.5,5,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.5,.5,5,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.5,.5,5,.009))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.5,.5,5,.008))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.5,.5,5.5,.008))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.7,.5,5.5,.008))), 1, mean))
(sumx <- apply((x<-replicate(50, runme(11.6,.5,5.6,.008))), 1, mean))
setwd("Results/MCMCglmm/Project - assoc mapping w binary traits/With related individuals + missing G/Type 1 error + power/mean center/")
load(".RData")
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf")
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', horiz = F, legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
pvals_analysis <- function(p_vals, al){
n <- length(p_vals); i <- 1
alpha <- c(.005,.01,.05)
result <- data.frame("alpha" = alpha, "Err_rate" = NA,"SE" = NA,"p_value" = NA)
for(a in alpha){
result$p_value[i] <- prop.test(x = sum(p_vals < a), n, p = a)$'p.val'
result$Err_rate[i] <- round(as.numeric(prop.test(x = sum(p_vals < a), n, p = a)$'est'),4)
result$SE[i] <- round(sqrt(mean(p_vals < a)*(1-mean(p_vals < a)) / n),4)
i <- i + 1
}; result$Err_rate[alpha==al]
}
draw_pval <- function(ind, p_vals_list, meth_list, percent){
p_vals <- p_vals_list[[ind]]
method <- meth_list[ind]
n <- length(p_vals)
uni2 <- rank(p_vals, ties.method='max'); names(uni2)=c()
plot(-log10(uni2/(n+1)),-log10(p_vals), type="n", ylab=expression('Observed (-log'[10]*' p-value)'), xlab=expression('Expected (-log'[10]*' p-value)'))
a=1:n
high <- qbeta(0.025, a, rev(a))
low <- qbeta(0.975, a, rev(a))
polygon(-log10(c(a/n,rev(a/n))), -log10(c(high, rev(low))), col ='gray', border = NA)
points(-log10(uni2/(n+1)),-log10(p_vals), pch=16,cex=.3)
title(expression(bold('Plot of observed vs. expected -log'[10]*' p-values')),line=2)
title(paste('With', method), line=.5)
abline(a=0,b=1,col="red")
}
n_p=rep(0, 6)
method_used = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC')
power_mat = matrix(NA, 6, 4)
type1err <- matrix(NA, 6, 4, dimnames = list(NULL, method_used))
index <- (1:6)[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
level = .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',index[k],',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
plot_power(power_mat)
# Type 1 Error
props <- seq(0,100,by=20)
n_pvals <- NULL
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',index[k],',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err; t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:4, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf")
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', horiz = F, legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
plot_power(power_mat)
setwd("../BLUE center/")
load(".RData")
n_p=rep(0, 6)
method_used = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC')
power_mat = matrix(NA, 6, 4)
type1err <- matrix(NA, 6, 4, dimnames = list(NULL, method_used))
index <- (1:6)[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
level = .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',index[k],',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
plot_power(power_mat)
# Type 1 Error
props <- seq(0,100,by=20)
n_pvals <- NULL
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',index[k],',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err; t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:4, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
n_pvals
setwd("../mean center/80%/")
load("A.RData")
n_p=rep(0, 6)
method_used = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC')
power_mat = matrix(NA, 6, 4)
type1err <- matrix(NA, 6, 4, dimnames = list(NULL, method_used))
index <- (1:6)[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
index
lapply(res,length)
length(res)
n_p=rep(0, 6)
method_used = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC')
power_mat = matrix(NA, 6, 4)
type1err <- matrix(NA, 6, 4, dimnames = list(NULL, method_used))
index <- (1:length(res))[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
index
load("B.RData")
n_p=rep(0, 6)
method_used = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC')
power_mat = matrix(NA, 6, 4)
type1err <- matrix(NA, 6, 4, dimnames = list(NULL, method_used))
index <- (1:length(res))[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
load("A.RData")
n_p=rep(0, 6)
method_used = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC')
power_mat = matrix(NA, 6, 4)
type1err <- matrix(NA, 6, 4, dimnames = list(NULL, method_used))
index <- (1:length(res))[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
load("B.RData")
index <- (3:4)[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
load("C.RData")
index
index <- (5:6)[lapply(res,length)>0]
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", 4)) # List for 4 methods
assign(paste0('p_vals',k,'_pow'), vector("list", 4)) # List for 4 methods
}
for(i in 1:4){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[index[k]] = n_p[index[k]] + 1; }
}
}
}
index = c(1,3,5)
level = .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',index[k],',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
plot_power(power_mat)
# Type 1 Error
props <- seq(0,100,by=20)
n_pvals <- NULL
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',index[k],',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err; t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:4, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
n_p
?legend
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf")
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
library(Hmisc)
plot_power(power_mat)
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf", width = 5, height = 6.5)
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
library(Hmisc)
plot_power(power_mat)
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf", width = 6.5, height = 5.5)
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
pvals_analysis <- function(p_vals, al){
n <- length(p_vals); i <- 1
alpha <- c(.005,.01,.05)
result <- data.frame("alpha" = alpha, "Err_rate" = NA,"SE" = NA,"p_value" = NA)
for(a in alpha){
result$p_value[i] <- prop.test(x = sum(p_vals < a), n, p = a)$'p.val'
result$Err_rate[i] <- round(as.numeric(prop.test(x = sum(p_vals < a), n, p = a)$'est'),4)
result$SE[i] <- round(sqrt(mean(p_vals < a)*(1-mean(p_vals < a)) / n),4)
i <- i + 1
}; result$Err_rate[alpha==al]
}
library(Hmisc)
plot_power(power_mat)
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf", width = 11.5, height = 10)
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf", width = 11.5, height = 10)
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf", width = 11.5, height = 10)
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
library(Hmisc)
plot_power(power_mat)
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf", width = 9.5, height = 9)
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
library(Hmisc)
plot_power(power_mat)
plot_power <- function(power_mat){
na_i <- n_p > 0
props <- seq(0,100,by=20)[na_i]
sds <- 2*sqrt(.25/n_p[na_i])
pdf("power_plot.pdf", width = 7.5, height = 7)
errbar(props, (y<-power_mat[na_i,1]), y+sds, y-sds, type = "b", pch=16, col='red', errbar.col = 'red', ylim = c(0,1), cap = .03,
ylab = "Power", xlab = "Proportion of variance on logit scale due to polygenic effects/covariates", xaxt = "n" )
for(i in 2:4){
errbar(props, (y<-power_mat[na_i,i]), y+sds, y-sds, type = "b",add=T, cap = .03,pch = c(15,17,18)[i-1], col=c('blue','lightgreen','purple')[i-1], errbar.col = c('blue','lightgreen','purple')[i-1])
}
axis(1, at = props, label = c("0/100", "20/80","40/60","60/40","80/20","100/0")[na_i])
legend('topright', legend = c('MCMCglmm', 'GMMAT','CARAT','CERAMIC'), pch = c(16,15,17,18), col = c('red','blue','lightgreen','purple'), cex=1.4, bty="n")
dev.off()
}
library(Hmisc)
plot_power(power_mat)
