# Comparing effect of increasing number of MCMC iter
R version 3.3.1 (2016-06-21) -- "Bug in Your Hair"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(mvtnorm)
> library(parallel)
> library(reshape)
> 
> library(MCMCglmm)
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:reshape’:

    expand

Loading required package: coda
Loading required package: ape
> 
> # Parameters for simulation
> N_fam <- 45
> n_person <- 22
> n_total <- N_fam * n_person
> 
> # Make pedigree
> ped1 <- data.frame(fam = NA, ind = 1:n_total, fa = NA, mo = NA)
> fa_ind <- c(NA,NA,NA,1,1,NA,1,NA,1,NA,4,4,4,6,6,6,8,8,10,10,10,10)
> mo_ind <- c(NA,NA,NA,2,2,NA,2,NA,2,NA,3,3,3,5,5,5,7,7,9,9,9,9)
> ped1[,c('mo','fa')] <- cbind(rep(mo_ind, N_fam)+ n_person*rep(0:(N_fam-1), each = n_person),
+                              rep(fa_ind, N_fam)+ n_person*rep(0:(N_fam-1), each = n_person))
> Prec <- inverseA(ped1[,c('ind','mo','fa')])$Ainv
> ped1[is.na(ped1)] <- 0
> ped1$fam <- rep(1:N_fam, each = n_person)
> write.table(ped1,'pedigree',row.names=FALSE, col.names=FALSE,sep='\t')
> 
> # Generate data
> phi <- as.matrix(read.table("add_phi_mat_n22")); colnames(phi) <- 1:n_person
> kin <- melt(diag(N_fam)%x%phi)[,c(2,1,3)]; kin = kin[kin[,1]<=kin[,2],]
> # Get fam for row and col indID
> kin$famrow <- ((kin[,1]-1)%/%n_person) + 1; kin$famcol <- ((kin[,2]-1)%/%n_person) + 1
> kin <- kin[kin$famrow==kin$famcol,]
> write.table(kin[,c(4,1:3)],'kinship',row.names=FALSE, col.names=FALSE,sep=' ')
> phi_inv <- solve(phi) #22x22 matrix
> sex <- rep(c(1,2,2,1,2,1,2,1,2,1,2,1,1,2,1,2,1,2,2,1,2,1),N_fam) #constant
> 
> peddrop <- function (parentmat, MAF) { # parentmat is matrix of parental info
+   nfound <- sum((parentmat[, 1] == 0) & (parentmat[, 2] == 0))
+   npeople <- dim(parentmat)[1]
+   haplos <- matrix(0, npeople, 2)
+   haplos[(parentmat[, 1] == 0) & (parentmat[, 2] == 0),] <- matrix(1:(2 * nfound), nfound, 2, byrow=T)
+   
+   for (i in 1:npeople) {
+     #/* When both parents are in the pedigree drop alleles down the pedigree */
+     if ((parentmat[i, 1] != 0) & (parentmat[i, 2] != 0)) {
+       #/* Randomly choose chrom. 0 or 1 to transmit to kid at each locus
+       trchrom = sample(1:2, 2, replace = T)
+       #// For GT haplotype
+       haplos[i, 1] = haplos[parentmat[i, 1], trchrom[1]];
+       haplos[i, 2] = haplos[parentmat[i, 2], trchrom[2]];
+     } 
+   }
+   
+   state <- as.numeric(runif(2 * nfound) < MAF) #1 if minor, 0 if major allele
+   genos <- matrix(0, npeople, 2)
+   for (i in 1:npeople) genos[i, ] = state[haplos[i,]]
+   
+   return(genos)
+ }
> 
> runme = function (dummy, Tu, Tot)
+ {
+   kt<<- kt + 1; write(kt, "iteration_track.txt")
+   add_var <- Tu * Tot
+   S_XB <- sqrt(Tot * (1 - Tu) / (363.67+.25+1)) # Ratio of target variance to var(X)
+   beta <- c(.05, 1, .5) * S_XB
+   LG <- log(1.1) # increase of 10% in the odds of being a case
+   int <- qlogis(0.1) - beta[1] * 31.86 -  beta[2] * 1.5 - LG * .1425  # Prevalence - b * E(X) - lambda * .1425
+   
+   age <- rep(c(73,75,46,43,40,46,40,43,47,51,18,21,15,15,12,9,13,17,24,21,18,14),N_fam) + runif(n_total,-1.5,1.5)
+   Z <- rnorm(n_total)
+   U <- c(t(rmvnorm(N_fam, sigma = add_var * phi))) 
+   G1 <- rowSums(peddrop( ped1[,c("fa","mo")], 0.1 ))
+   G2 <- rowSums(peddrop( ped1[,c("fa","mo")], 0.5 ))
+   
+   Y <- rbinom(n_total, size = 1, prob = plogis(int + U + LG * ((G1 > 0) & (G2 > 0)) +	age*beta[1] + sex*beta[2] + Z*beta[3]))
+   fam_data = data.frame(Y=Y, age = age, sex = sex, Z = Z, idU = 1:n_total)
+   
+   ### MCMC glmm
+   # MCMCtime <- proc.time()
+   prior1 <- list(R = list(V = 1, fix=1),
+                  G = list(G1 = list(V = 1, nu = 1, alpha.mu=0, alpha.V=10^2)))
+   mMCMC<-MCMCglmm(Y ~ 1 + age + sex + Z, random =~idU, family = "categorical",
+                   ginverse = list(idU = Prec), prior=prior1,
+                   data = fam_data, verbose = F, nitt=dummy * 250e3, thin=500, burnin=10e3)
+   
+   k <- ((16*sqrt(3))/(15*pi))^2
+   est_add_var <- posterior.mode(mMCMC$VCV[,1] / (1 + k))
+   est_beta <- posterior.mode(mMCMC$Sol[,1:4] / sqrt(1 + k))
+   
+   ### Can't do check of (Y - pi) - Prec * u* = 0 b/c u* is not computed in MCMCglmm at each iteration 
+   # --> increase number of MCMC iter so that the posterior for u is well estimated ???
+   # con_pi <- as.vector(predict(mMCMC, posterior = "mode", type = "response")) # conditional on posterior mode of parameters (beta, u) -- E(pi|u)
+   mar1 <- as.vector(predict(mMCMC, marginal = ~idU, type = "response")) # E(pi)
+   ## Get marginal pi by approx from formula 2.14 in mcmcglmm course notes
+   # ru <- rowSums(mMCMC$VCV)
+   # X <- as.matrix(mMCMC$X)
+   # b <- mMCMC$Sol
+   # xb <- tcrossprod(b, X)
+   # mar2<- colMeans(plogis(xb - .5 * ru * tanh(xb *  (1 + 2 * exp(-0.5 * ru))/6)))   #  RMSE = sqrt(sum((mar1-mar2)^2))  -- closer
+   
+   # Generate 1000 G
+   m <- 5000
+   G_sub <- replicate(m, rowSums(peddrop( ped1[,c("fa","mo")], 0.3 ))) # n * 1000 matrix
+   
+   # Numerator
+   T_num <- as.vector(crossprod(G_sub, Y - mar1))^2
+   # T_num1 <- as.vector(crossprod(G_sub, Y - con_pi))^2
+   # for(i in 1:2) assign(paste("T_num",i+1,sep=""), eval(parse(text = paste("as.vector(crossprod(G_sub, Y - mar",i,"))^2", sep=""))))
+   
+   # }
+   # T_denumV1 <- get_denum2(con_pi)
+   # for(i in 1:2) assign(paste("T_denumV",i+1,sep=""), eval(parse(text = paste("get_denum2(mar",i,")", sep=""))))
+   
+   # Retrospective version
+   Phimat <- diag(N_fam) %x% phi
+   get_denum_retro <- function(G, Matdenum){ 
+     maf <- mean(G) / 2 #(sum(G) + 1) / ((n_total + 1) * 2)  --> Not necessary since G is common variant
+     2 * maf * (1 - maf) * Matdenum
+   }
+   YPhiY <- crossprod(Y - mar1, Phimat) %*% (Y - mar1) #marginal mean
+   Tr_denumR <- apply(G_sub, 2, get_denum_retro, YPhiY)
+   
+   # # Prospective
+   # i=1
+   # eval(parse(text = paste("draw_quant(T_num",i,"/T_denum",i,")",sep=""))) # based on taylor approx
+   # eval(parse(text = paste("draw_quant(T_num",i,"/T_denumV",i,")",sep=""))) # based on fisher info
+   # Retrospective
+   # draw_quant(T_num2 / Tr_denumR)
+   
+   #### P-values
+   draw_pval <- function(p_vals){
+     n = length(p_vals)
+     uni2= rank(p_vals, ties.method='max'); names(uni2)=c()
+     plot(-log10(uni2/(n+1)),-log10(p_vals), type="n", ylab=expression('Observed (-log'[10]*' p-value)'), xlab=expression('Expected (-log'[10]*' p-value)'))
+     a=1:n
+ 	high <- qbeta(0.025, a, rev(a))
+ 	low <- qbeta(0.975, a, rev(a))
+ 	polygon(-log10(c(a/n,rev(a/n))), -log10(c(high, rev(low))), col ='gray', border = NA)
+ 	points(-log10(uni2/(n+1)),-log10(p_vals), pch=16,cex=.3) 
+     title(expression(bold('Plot of observed vs. expected -log'[10]*' p-values')),line=3.2)
+     title(paste("Setting:", Tu,"/", Tot, "- #MCMC iter:", 250*dummy,"k"), line=1.5)
+     abline(a=0,b=1,col="red")
+   }
+   pvals_analysis <- function(p_vals){
+     n <- length(p_vals); i <- 1
+     alpha <- c(.005,.01,.05)
+     result <- data.frame("alpha" = alpha, "Err_rate" = NA,"SE" = NA,"p_value" = NA)
+     for(a in alpha){
+       result$p_value[i] <- prop.test(x = sum(p_vals < a), n, p = a)$'p.val'
+       result$Err_rate[i] <- round(as.numeric(prop.test(x = sum(p_vals < a), n, p = a)$'est'),4)
+       result$SE[i] <- round(sqrt(mean(p_vals < a)*(1-mean(p_vals < a)) / n),4)
+       i <- i + 1
+     }; result
+   }
+   
+   # Prospective
+   # for(i in 1:3) assign(paste("pvals",i,sep=""), eval(parse(text = paste("pchisq(T_num",i,"/ T_denum",i,", df = 1, lower.tail = F)", sep=""))))
+   # for(i in 1:3) assign(paste("pvalsV",i,sep=""), eval(parse(text = paste("pchisq(T_num",i,"/ T_denumV",i,", df = 1, lower.tail = F)", sep=""))))
+   # Retrospective
+   pvalsR<- pchisq(T_num / Tr_denumR, df = 1, lower.tail = F)
+   
+   pdf(paste("pvals_Retro",dummy,"_",Tu*100,".pdf"))
+   # for(i in 1:3){
+     # eval(parse(text = paste("draw_pval(pvals",i,",",i,")", sep="")))
+     # eval(parse(text = paste("pvals_analysis(pvals",i,")", sep="")))
+   # }
+   draw_pval(pvalsR)
+   result_out = pvals_analysis(pvalsR)
+   dev.off()
+   
+   return(result_out)
+ }
> 
> ########################### 
> ################## Analysis
> M = rbind(c(0,1.1),c(.2,1.2),c(.4,1.2), c(.6,1.3),c(.8,1.3),c(1,1.3))
> n_M = dim(M)[1]
> # Will be a list (over Tu/Te) of a list (over rep) of matrices (GMMAT and MCMC)
> res = rep(list(list()), n_M) 
> n_rep = 2; kt <- 0 # To keep track of iterations
> 
> for(i in 1:n_M) {
+   res[[i]] = mclapply(1:n_rep, runme, mc.cores = 2, Tu= M[i,1], Tot = M[i,2])
+ 	save.image() #Save the res object
+ }
> 
> # sendmemail()
> 
> 
> proc.time()
     user    system   elapsed 
24598.049    17.577 18412.252 

# Type 1 Error results -- 5000 marker replicates ( = p-values)
0%
  alpha Err_rate     SE   p_value
1 0.005   0.0044 0.0009 0.6161919
2 0.010   0.0096 0.0014 0.8311704
3 0.050   0.0476 0.0030 0.4555354

20%
  alpha Err_rate     SE   p_value
1 0.005   0.0062 0.0011 0.2701312
2 0.010   0.0108 0.0015 0.6188588
3 0.050   0.0492 0.0031 0.8203382

40%
  alpha Err_rate     SE   p_value
1 0.005   0.0046 0.0010 0.7636030
2 0.010   0.0110 0.0015 0.5224313
3 0.050   0.0532 0.0032 0.3145249

60%
  alpha Err_rate     SE    p_value
1 0.005   0.0070 0.0012 0.05681025
2 0.010   0.0120 0.0015 0.17692901
3 0.050   0.0576 0.0033 0.01496102

80%
  alpha Err_rate     SE    p_value
1 0.005   0.0056 0.0011 0.61619188
2 0.010   0.0120 0.0015 0.17692901
3 0.050   0.0552 0.0032 0.09799379

100%
  alpha Err_rate     SE   p_value
1 0.005   0.0034 0.0008 0.1326421
2 0.010   0.0100 0.0014 1.0000000
3 0.050   0.0506 0.0031 0.8711315