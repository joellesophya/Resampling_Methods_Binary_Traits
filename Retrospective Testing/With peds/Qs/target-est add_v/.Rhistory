power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
dev.off()
n_p <- rep(0, length(index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]))
props <- seq(0,100,10)[index]
n_meth <- length( (method_used = c('MCMCglmm', 'CERAMIC')) )
power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
power_matA <- power_mat
load("C.RData")
n_p <- rep(0, length(index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]))
props <- seq(0,100,10)[index]
n_meth <- length( (method_used = c('MCMCglmm', 'CERAMIC')) )
power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
rbind(power_matA,power_mat)
load("C:/Users/JOELLE/Google Drive/Reasearch Mary Sara _ SAMSUNG/Permutation based methods/Binary trait/Results/MCMCglmm/Project - assoc mapping w binary traits/With peds + missing G/Type 1 error + power/w post. mean of u/y-mu/.RData")
setwd("C:/Users/JOELLE/Google Drive/Reasearch Mary Sara _ SAMSUNG/Permutation based methods/Binary trait/Results/MCMCglmm/Project - assoc mapping w binary traits/With peds + missing G/Type 1 error + power/w post. mean of u/y-mu/")
n_p <- rep(0, length(index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]))
props <- seq(0,100,10)[index]
n_meth <- length( (method_used = c('MCMCglmm', 'CERAMIC')) )
power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
M
index
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
power_mat
load("C:/Users/JOELLE/Google Drive/Reasearch Mary Sara _ SAMSUNG/Permutation based methods/Binary trait/Results/MCMCglmm/Project - assoc mapping w binary traits/With peds + missing G/Type 1 error + power/w post. mean of u/Eu/A.RData")
setwd("C:/Users/JOELLE/Google Drive/Reasearch Mary Sara _ SAMSUNG/Permutation based methods/Binary trait/Results/MCMCglmm/Project - assoc mapping w binary traits/With peds + missing G/Type 1 error + power/w post. mean of u/Eu/")
n_p <- rep(0, length(index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]))
props <- seq(0,100,10)[index]
n_meth <- length( (method_used = c('MCMCglmm','CERAMIC')) )
power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
power_mat1 <- power_mat
load("B.RData")
n_p <- rep(0, length(index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]))
props <- seq(0,100,10)[index]
n_meth <- length( (method_used = c('MCMCglmm','CERAMIC')) )
power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
power_mat2 <- power_mat
rm(power_matA)
load("C.RData")
n_p <- rep(0, length(index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]))
props <- seq(0,100,10)[index]
n_meth <- length( (method_used = c('MCMCglmm','CERAMIC')) )
power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
power_mat3 <- power_mat
load("B.RData")
n_p <- rep(0, length(index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]))
props <- seq(0,100,10)[index]
n_meth <- length( (method_used = c('MCMCglmm','CERAMIC')) )
power_mat = matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
type1err <- matrix(NA, length(n_p), n_meth, dimnames = list(paste(props, 100-props, sep = "/"), method_used))
n_pvals <- NULL
for(k in index){
assign(paste0('p_vals',k,'_t1err'), vector("list", n_meth)) # List for the methods
assign(paste0('p_vals',k,'_pow'), vector("list", n_meth)) # List for the methods
}
for(i in 1:n_meth){
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
eval(parse(text=paste0('p_vals',index[k],'_t1err[[',i,']] <- append(p_vals',index[k],'_t1err[[',i,']] , res[[',k,']][[',j,']]$Ty[,',i,'])')))
eval(parse(text=paste0('p_vals',index[k],'_pow[[',i,']] <- append(p_vals',index[k],'_pow[[',i,']] , res[[',k,']][[',j,']]$Po[',i,'])')))
if (i ==1) n_p[k] = n_p[k] + 1; }
}
}
}
# index <- 1:6
level <- .05
# Power
for(k in 1:length(index)){
eval(parse(text=paste0('power_mat[',k,',] <- unlist(lapply(p_vals',index[k],'_pow, function(x) mean(x<level)))')))
}
library(Hmisc)
Tu_vals <- M[sapply(res,length) > 0, 1]
plot_power(na.omit(power_mat), Tu_vals, method_used)
# Type 1 Error
props <- seq(0,100,by=10)
for(k in 1:length(index)){
eval(parse(text=paste0('type1err[',k,',] <- unlist(lapply(p_vals',index[k],'_t1err, pvals_analysis, al = .05))')))
eval(parse(text=paste0('n_pvals[',k,'] <- length(p_vals',index[k],'_t1err[[1]])')))
}
type1err;t(sapply(n_pvals, function(x).05 + c(-1,1)*2*sqrt(.05*(1-.05)/x)))
png("t1err_plot%01d.png", width = 12, height = 9, units = 'in', res=200)
par(mfrow = c(2,2))
for(k in 1:length(index)){
eval(parse(text=paste0('lapply(1:n_meth, draw_pval, p_vals',index[k],'_t1err, method_used)')))
title(paste('Polygenic effect / Covariates:',props[index[k]],'/',100-props[index[k]]), outer=TRUE, cex=1.1, line = -1.5)
}
dev.off()
Tu_vals
Tu_vals <- c(.1,.4,.8)
plot_power(na.omit(power_mat), Tu_vals, method_used)
rbind(power_mat1,power_mat2,power_mat3)
plot_power(rbind(power_mat1,power_mat2,power_mat3), Tu_vals, method_used)
dev.off()
plot_power(rbind(power_mat1,power_mat2,power_mat3), Tu_vals, method_used)
23413.321/3600
1987.782/3600
31987.782/3600/3
31987.782/3600/2
G1 <- rbinom(n_total,2,.1)
res_fam <- matrix(Prec%*%1, n_person, N_fam)
T_num_G <- colSums(Gmat * c(crossprod(H_mat, res_fam)))^2
dim(crossprod(Prec,1))
dim(crossprod(Prec,interger(n_total)+1))
dim(crossprod(Prec,integer(n_total)+1))
Gmat <- G1 <- rbinom(n_total,2,.1)
res_fam <- matrix(crossprod(Prec, integer(n_total)+1), n_person, N_fam)
T_num_G <- colSums(Gmat * c(crossprod(H_mat, res_fam)))^2
dim(res_fam)
length(Gmat)
length(c(crossprod(H_mat, res_fam)))
sum(Gmat * c(crossprod(H_mat, res_fam)))
sum(Gmat * c(crossprod(H_mat, res_fam)))^2
YHPhiY <- sum(c(crossprod(H_mat, res_fam)) * c(crossprod(phi, res_fam)))
YPhiY
YHPhiY
T_denum_G <- get_denum_retro(Gmat, YHPhiY)
get_denum_retro <- function(G, Matdenum){
mafs <- colMeans(G) / 2
2 * mafs * (1 - mafs) * Matdenum
}
YHPhiY <- sum(c(crossprod(H_mat, res_fam)) * c(crossprod(phi, res_fam)))
T_denum_G <- get_denum_retro(Gmat, YHPhiY)
get_denum_retro <- function(G, Matdenum){
mafs <- mean(G) / 2
2 * mafs * (1 - mafs) * Matdenum
}
YHPhiY <- sum(c(crossprod(H_mat, res_fam)) * c(crossprod(phi, res_fam)))
T_denum_G <- get_denum_retro(Gmat, YHPhiY)
T_denum_G
pvalstot <- pchisq(T_num_G / T_denum_G, df = 1, lower.tail = F)
res_fam <- matrix(EU_hat, n_person, N_fam)
T_num_G <- sum(Gmat * c(crossprod(H_mat, res_fam)))^2
# Retrospective denominator
get_denum_retro <- function(G, Matdenum){
mafs <- mean(G) / 2
2 * mafs * (1 - mafs) * Matdenum
}
YHPhiY <- sum(c(crossprod(H_mat, res_fam)) * c(crossprod(phi, res_fam)))
T_denum_G <- get_denum_retro(Gmat, YHPhiY)
pvalstot <- pchisq(T_num_G / T_denum_G, df = 1, lower.tail = F)
pvalstot
(300e3-15e3)/500
load("C:/Users/JOELLE/Google Drive/Reasearch Mary Sara _ SAMSUNG/Permutation based methods/Binary trait/Results/MCMCglmm/Project - assoc mapping w binary traits/With peds + missing G/effect of asc/est_avar/.RData")
setwd("C:/Users/JOELLE/Google Drive/Reasearch Mary Sara _ SAMSUNG/Permutation based methods/Binary trait/Results/MCMCglmm/Project - assoc mapping w binary traits/With peds + missing G/effect of asc/est_avar/")
res[[1]][[1]]
res[[1]][[1]][1]
res[[1]][[1]][2]
res[[1]][[1]][[2]
]
target_v <- est_v <- NULL
index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
target_v<- append(target_v, res[[k]][[j]][[1]])
est_v<- append(est_v, res[[k]][[j]][[2]])
}
}
}
str(target_v)
mean(target_v)
boxplot(list(target_v, est_v), ylim=c(0,5)))
boxplot(list(target_v, est_v), ylim=c(0,5))
boxplot(list(target_v, est_v))
boxplot(list(target_v, est_v)), ylim=c(0,25))
boxplot(list(target_v, est_v)), ylim=c(0,25)
boxplot(list(target_v, est_v), ylim=c(0,25))
summary(list(target_v, est_v))
sapply(list(target_v, est_v), summary)
plot(target_v, est_v, ylim=c(0,5))
hist(target_v)
cond1 <- est_v < 50
plot(target_v[cond1], est_v[cond1])
cond1 <- est_v < 7
plot(target_v[cond1], est_v[cond1])
eiling(max(target_v))
ceiling(max(target_v))
cond1 <- est_v < ceiling(max(target_v))
plot(target_v[cond1], est_v[cond1])
mean(cond1)
target_v <- est_v <- matrix(NA, n_rep, nrow(M))
index <- ceiling(M[,1]*10+1)[sapply(res,length) > 0]
for(j in 1:n_rep){
for(k in 1:length(index)){
if(is.double(unlist(res[[k]][[j]]))){
target_v[j,k]<- res[[k]][[j]][[1]]
est_v[j,k]<- res[[k]][[j]][[2]]
}
}
}
dim(est_v)
head(est_v)
sapply(list(target_v, est_v), summary)
M[,1]*M[,2]
boxplot(list(target_v, est_v), ylim=c(0,25))
boxplot(target_v)
boxplot(cbind(target_v, est_v), ylim=c(0,25))
edit(MCMCglmm)
edit(MCMCglmm::MCMCglmm)
boxplot(cbind(target_v, est_v), ylim=c(0,5))
M
M[,1]*M[,2]
1000e3-15e3
985e3/500
mean(c(1,2,2,1,2,1,2,1,2,1,2,1,1,2,1,2,1,2,2,1,2,1))
nrow(M)
load("C:/Users/JOELLE/Google Drive/Reasearch Mary Sara _ SAMSUNG/Permutation based methods/Binary trait/Results/MCMCglmm/Project - assoc mapping w binary traits/With peds + missing G/effect of asc/eff.siz/Wasc_eff_siz.RData")
ls()
M
n_rep
str(res)
res[[1]][[1]]
M
crossprod(M)
for(j in 1:n_rep){
ests$add_v[j] <- res[[1]][[j]][[3]]
ests$eff_siz[j] <- res[[1]][[j]][[4]]
}
ests <- data.frame(add_v = integer(n_rep), eff_siz = integer(n_rep))
for(j in 1:n_rep){
ests$add_v[j] <- res[[1]][[j]][[3]]
ests$eff_siz[j] <- res[[1]][[j]][[4]]
}
summary(ests)
250-5
195e3/500
245e3/500
plot(ests)
plot(ests$eff_siz,ests$add_v)
plot(ests$eff_siz,ests$add_v, pch=16)
plot(ests$eff_siz,ests$add_v, pch=16, cex=.4)
plot(ests$eff_siz[ests$eff_siz<100],ests$add_v[ests$eff_siz<100], pch=16, cex=.4)
boxplot(ests$add_v)
boxplot(ests$add_v[ests$eff_siz>20])
boxplot(ests$add_v[ests$eff_siz>50])
boxplot(ests$add_v[ests$eff_siz>100])
boxplot(ests$add_v[ests$eff_siz>200])
boxplot(ests$add_v[ests$eff_siz>300])
boxplot(ests$add_v[ests$eff_siz>400])
add_va
